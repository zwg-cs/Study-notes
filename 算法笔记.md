## 认识复杂度的简单的排序
常数操作->常数操作数量->时间复杂度O(读作big O，只要高阶项)  
算法流程的好坏，先看时间复杂度，再分析不同数据样本实际的运行时间

选择排序和冒泡排序
```cpp
//选择排序
void SelectedSort(int arr[], int length)
{
	if (length < 2)
	{
		return;
	}
	for (int i = 0; i < length; i++)
	{
		int minValue = i;
		for (int j = i; j < length; j++)
		{
			if (arr[minValue] > arr[j])
			{
				minValue = j;
			}
		}
		swapArr(arr, i, minValue);
	}
}

//冒泡排序
void BubbleSort(int arr[], int length)
{
	if (length < 2)
	{
		return;
	}

	for (int i = 0; i < length; i++)
	{
		for (int j = 1; j < length - i; j++)
		{
			if (arr[j-1] > arr[j])
			{
				swapArrElem(arr, j, j-1);
			}
		}
	}
}

```

***Attention***
```cpp
// 打印数组
void printArr(int arr[])
{
    int lenght = sizeof(arr) / sizeof(arr[0]);
	for (int i = 0; i < length; i++)
	{
		printf("%d ", arr[i]);
	}
}
在函数参数中，int arr[] 会被自动转换为 int* arr，也就是说，arr 实际上是一个指向数组首元素的指针。
对于一个指针，sizeof(arr) 返回的是指针的大小，而不是数组的大小。对于大多数系统，指针大小是 4 或 8 字节（32 位或 64 位），而 sizeof(arr[0]) 是 sizeof(int)，通常是 4 字节。
```

异或运算->无进位相加
```
a : 1 0 1 1 0
b : 0 0 1 1 1
-------------
^ : 1 0 0 0 1
异或运算的一些性质
(1) 0 ^ N = N, N ^ N = 0
(2) 结合律：(a^b)^c = a^(b^c) 交换律：a^b=b^a
(3) 同一批数异或结果是同一个
```

可以使用异或运算交换数组中两个元素的值，前提是这里的i和j指向不同的内存，如果指向同一块内存，会将该位置元素值变为0
```cpp
//使用异或的方法交换数组中两个元素的值
void swapArrElemByXOR(int arr[], int i, int j)
{
	arr[i] = arr[i] ^ arr[j];
	arr[j] = arr[i] ^ arr[j];
	arr[i] = arr[i] ^ arr[j];
}
```

异或问题1：有N个数的数组，其中有一种数出现奇数次，其他所有数出现偶数次，找出这个出现奇数次的数，要求时间复杂度O(N)，空间复杂度O(1)         
解答：声明一个变量，从头到尾异或，最后得到的数就是出现奇数次的数
```cpp
int EvenTiemsOddTimes(int arr[], int length)
{
	int eor = 0;
	for (int i = 0; i < length; i++)
	{
		eor = eor ^ arr[i];
	}
	return eor;
}
```

异或问题2：有N个数的数组，其中有两种数出现奇数次，其他所有数出现偶数次，找出这个出现奇数次的数，要求时间复杂度O(N)，空间复杂度O(1)
解答：假如两种现奇数次的数为a和b，声明一个变量eor，从头到尾异或，得到结果为eor=a^b，a^b不为0，a不等于b，a和b在某一位肯定不一样，同理eor的某一位肯定为1，
```cpp
pair<int, int> EvenTiemsOddTimesNum2(int arr[], int length)
{
	int eor = 0;
	for (int i = 0; i < length; i++)
	{
		eor = eor ^ arr[i];
	}
	// eor = a ^ b; eor != 0; eor的某一位一定为1

	//找出某个数最右侧出现的1
	int rightOne = eor & (-eor);  // -eor表示eor的补码(取反加1)，在和eor按位与运算 0000000100

	int onlyOne = 0;
	for (int i = 0; i < length; i++)
	{
		if ((arr[i] & rightOne) == 0) // 只取一边，这里分为0和不等于0
		{
			onlyOne = onlyOne ^ arr[i];
		}
	}

	pair<int, int> result(onlyOne, onlyOne ^ eor);
	return result;

}
```

插入排序
数据状况不同，时间复杂度不一样，算法流程按照最差情况估计时间复杂度
```cpp
void insertionSort(int arr[], int length)
{
	if (length < 2)
	{
		return;
	}

	for (int i = 1; i < length; i++)  // 0-i有序
	{
		for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--)
		{
			swapArrElem(arr, j, j + 1);
		}
	}
}
```


二分查找，时间复杂度$O(log_2 N)$  
在一个有序数组中，找某个数是否存在
```cpp
bool BSExist(int arr[], int length, int num)
{
	if (length < 2)
	{
		return arr[0] == num;
	}
	int left = 0;
	int right = length - 1;
	int mid = 0;
	while (left < right)
	{
		// (right - left) >> 1 表示将right-left的结果右移一位，等于除2
		mid = left + ((right - left) >> 1); 

		if (arr[mid] == num)
		{
			return true;
		}
		else if (arr[mid] < num)
		{
			left = mid + 1;
		}
		else {
			right = mid - 1;
		}
	}
	return false;
}
```

在一个有序数组中，找>=某个数最左侧的位置
```cpp
int BSNearLeft(int arr[], int length, int num)
{
	int left = 0;
	int right = length - 1;
	int mid = 0;
	int mark = -1;
	while (left <= right)  //注意这里的等号
	{
		mid = left + ((right - left) >> 1);

		if (arr[mid] >= num)
		{
			mark = mid;
			right = mid - 1;
		}
		else {
			left = mid + 1;
		}
	}
	return mark;

}
```
局部最小值问题，无序数组，相邻数不相等，先判断头尾
```cpp
int FindOneLessValueIndex(int arr[], int length)
{
	if (length == 0) return -1;
	if (length == 1 || arr[0] < arr[1]) return 0;
	if (arr[length - 1] < arr[length - 2]) return length - 1;
	
	int left = 1;
	int right = length - 2;
	int mid = 0;
	while (left < right)
	{
		mid = (right + left) / 2;
		if (arr[mid] > arr[mid - 1])
		{
			right = mid - 1;
		}
		else if (arr[mid] > arr[mid + 1])
		{
			left = mid + 1;
		}
		else {
			return mid;
		}
	}

	return left;
}
```


### 递归找出最大值
```cpp
mid = (L + R) / 2; //(L + R)容易溢出
mid = L + (R - L) / 2;  //这种写法更好，不容易溢出
mid = L + ((R - L) >> 1);  //更更好，右移一位比除2快

```

```cpp
int MaxFromLtoR(int arr[], int L, int R)
{
	if (L == R)  // 如果L和R相等，范围内只有一个数
	{
		return arr[L];
	}
	int mid = L + ((R - L) >> 1);  // 避免溢出，同时速度更快
	int left_max = MaxFromLtoR(arr, L, mid);
	int right_max = MaxFromLtoR(arr, mid + 1, R);
	return max(left_max, right_max);

}
```

关于master公式    
$T(N) = a \times T(\frac{N}{b})+O(N^d)$    
$T(N)$：表示母问题的数据量时$N$级别的   
$T(\frac{N}{b})$：表示子问题的规模（每一次子过程的规模都是等量的$\frac{N}{b}$的规模）   
$a$：表示子问题调用的次数   
$O(N^d)$：表示剩下过程的时间复杂度是多少   
上面的MaxFromLtoR：a=;b=2;d=0;   

$当log_b^a<d时 ~~ O(N^d)$   
$当log_b^a>d时 ~~ O(N^{log_b^a})$   
$当log_b^a==d时 ~~ O(N^d * log^N)$

### 归并排序
```cpp
void MergeSort(int arr[], int L, int R)
{
	if (L == R) {
		return;
	}
	int mid = L + ((R - L) >> 1);  // 获取中点
	MergeSort(arr, L, mid);  // 左边位置所有元素排序 
	MergeSort(arr, mid + 1, R);  // 右边位置所有元素排序
	Merge(arr, L, mid, R);  // 将两边排序结果融合
}

void Merge(int arr[], int L, int M, int R)
{
	int* help = new int[R - L + 1];  //声明一个动态数组
	int i = 0;
	int p1 = L;  // 左边第一个位置
	int p2 = M+1;  // 右边第一个位置

	while (p1 <= M && p2 <= R)  // 融合（外排序）
	{
		help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
	}

	while (p1 <= M)  // 左边还有剩余
	{
		help[i++] = arr[p1++];
	}

	while (p2 <= R)  // 右边还有剩余
	{
		help[i++] = arr[p2++];
	}

	for (i = 0; i < (R - L + 1); i++)  // 结果拷贝到原数组
	{
		arr[L + i] = help[i];
	}
}
时间复杂度：O(N*logN)   
空间复杂度：O(N)
```
### 小和问题
一个数右边有多少个数比它大
```cpp
int SmallSum(int arr[], int length)
{
	if (length < 2)
	{
		return 0;
	}
	return MergeSortSum(arr, 0, length - 1);  // 使用归并排序求小和
}

int MergeSortSum(int arr[], int L, int R)
{
	if (L == R)
	{
		return 0;
	}
	int mid = L + ((R - L) >> 1);
	return MergeSortSum(arr, L, mid) +   // 左边部分排序，求小和
		MergeSortSum(arr, mid + 1, R) +   // 右边部分排序，求小和
		MergeSum(arr, L, mid, R);  // 两边合并，求小和
}

int MergeSum(int arr[], int L, int mid, int R)
{
	int* help = new int[R - L + 1];
	int i = 0;
	int p1 = L;
	int p2 = mid + 1;
	int res = 0;
	while (p1 <= mid && p2 <= R)
	{
		res += arr[p1] < arr[p2] ? (R - p2 + 1) * arr[p1] : 0;  // 左边比右边小，才会产生小和
		help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
	}

	while (p1 <= mid)
	{
		help[i++] = arr[p1++];
	}
	while (p2 <= R)
	{
		help[i++] = arr[p2++];
	}

	for (i = 0; i < (R - L + 1); i++)
	{
		arr[L + i] = help[i];
	}
	return res;

}
```

### 逆序对问题
在一个数组中左边的数如果比右边的数大，则这两个数构成一个逆序对，请打印所有逆序对



### 快速排序
```cpp
void QuickSort(int arr[], int L, int R)
{
	if (L < R)
	{
		std::random_device rd;
		std::mt19937 gen(rd());
		std::uniform_real_distribution<> dis(0.0, 1.0);
		// static_cast<int>(dis(gen)) 产生一个（0，1）的随机数
		SwapArrElem(arr, L + static_cast<int>(dis(gen) * (R - L + 1)), R);  //随机选择一个数，交换到最后位置
		int* p = partition(arr, L, R);  // 返回相等区域的边界
		QuickSort(arr, L, p[0] - 1);
		QuickSort(arr, p[1] + 1, R);

		// 释放partition函数分配的内存
		delete[] p;

	}
}

void SwapArrElem(int arr[], int index_1, int index_2)
{
	int temp = arr[index_2];
	arr[index_2] = arr[index_1];
	arr[index_1] = temp;
}

// 返回相等区域边界
int* partition(int arr[], int L, int R)
{
	int less = L - 1;  // <区右边界
	int more = R;  // >区左边界
	while (L < more)  // L表示当前数的位置, arr[R]是划分值
	{
		if (arr[L] < arr[R])  // 当前数小于划分数
		{
			SwapArrElem(arr, ++less, L++);
		}
		else if (arr[L] > arr[R])  // 当前数大于划分数
		{
			SwapArrElem(arr, --more, L);
		}
		else
		{
			L++;
		}
	}
	SwapArrElem(arr, more, R);
	int* res = new int[2];
	res[0] = less + 1;
	res[1] = more;
	return res;
}
```   

### 堆结构
完全二叉树    
大根堆：每个子树头节点的值为最大值    
小根堆：每个子树头节点的值为最小值
```
      i      或者       i-1/2
    /   \              /   \
  2i+1  2i+2          i    i+1
```

heapInsert过程   O(logN)
```cpp
// 插入到堆中 
void HeapInsert(int arr[], int index)
{
	while (arr[index] > arr[(index - 1) / 2])  // 如果子节点大于父节点
	{
		SwapArrElem(arr, index, (index - 1) / 2);  //交换子节点和父节点的值
		index = (index - 1) / 2;  // 上一次的父节点继续作为子节点，与其父节点做比较
	}
}
```   
heapify 堆化 O(logN)    
```cpp
// 堆化过程 heapify 
void Heapify(int arr[], int index, int size)
{
	int left = 2 * index + 1;  // 找到左子节点
	while (left < size)  // 判断是否在堆范围内（不一定是数组范围）
	{
		int largest = left + 1 < size && arr[left + 1] > arr[left] ? left + 1 : left;  // 找到左右子节点中的最大值
		largest = arr[largest] > arr[index] ? largest : index;  // 判断index是否比子节点的最大值大
		if (largest == index)  //index节点大于其左右子节点
		{
			break;
		}
		SwapArrElem(arr, largest, index);  // index节点小于其左右子节点中至少的一个，交换
		index = largest;  // 更新index
		left = index * 2 + 1;  // 更新左子节点
	}
}
```

堆排序
```cpp
// 堆排序  整体算法时间复杂度 O(N*logN) 空间复杂度 O(1)
void heapSort(int arr[], int length)
{
	// 判断数组大小
	if (length < 2)
	{
		return;
	}

	// 将整个数组变成一个大根堆  这一过程O(N*logN)
	// for (int i = 0; i < length; i++) // O(N)
	// {
	// 	HeapInsert(arr, i);  // O(logN)
	// }

	// 将数组变成大根堆的另一种方法，这个方法更好
	// 不会做叶子节点
	for (int i = length - 1; i >= 0; i--)
	{
		Heapify(arr, i, length);
	}
	
	// 打印大根堆
	cout << "大根堆：" << endl;
	PrintArr(arr, length);

	// 堆排序过程 这一过程也是O(N*logN)
	int heapSize = length;
	SwapArrElem(arr, 0, --heapSize);
	while (heapSize > 0)  // O(N)
	{
		Heapify(arr, 0, heapSize);  // O(logN)
		SwapArrElem(arr, 0, --heapSize);  //O(1)
	}
}
```

优先级队列结构，堆结构  
堆排序扩展题目  
已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。
```cpp
void sortedArrDistanceLessK(int arr[], int k, int length)
{
	// 创建一个小根堆
	priority_queue<int, vector<int>, greater<int>> minHeap;

	int index = 0;
	// 放到元素个数为K的小根堆
	for (; index < min(length, k); index++)
	{
		minHeap.push(arr[index]);
	}

	int i = 0;
	for (; index < length; index++)
	{
		minHeap.push(arr[index]); // 入堆
		arr[i] = minHeap.top();  // 顶部最小值出堆
		minHeap.pop();
	}

	while (!minHeap.empty())
	{
		arr[i++] = minHeap.top();  // 出堆
		minHeap.pop();
	}
}
```

桶排序    
计数排序，基数排序
```cpp
// 基数排序
void radixSort(int arr[], int length)
{
	if (length < 2) return;

	radixSort(arr, 0, length - 1, maxbits(arr, length));
}

// 基数排序
void radixSort(int arr[], int begin, int end, int digit)
{
	int radix = 10; // 0-9一共10位
	int i = 0, j = 0;
	int* bucket = new int[end - begin + 1]();  // 桶，注意设初值为0
	for (int d = 1; d <= digit; d++)
	{
		int* count = new int[radix]();  // 注意设初值为0

		// 计算频数
		for (i = begin; i <= end; i++)
		{
			j = getDigit(arr[i], d);
			count[j]++;
		}

		// 切片准备
		for (i = 1; i < radix; i++)
		{
			count[i] = count[i] + count[i - 1];  // 有多少小于等于
		}

		// 0 2 2 1 0 0 0 0 0 0 -> 0 2 4 5 5 5 5 5 5 5

		// 从后面开始遍历
		for (i = end; i >= begin; i--)
		{
			j = getDigit(arr[i], d);
			bucket[count[j] - 1] = arr[i];
			count[j]--;
		}

		
		for (i = begin, j = 0; i <= end; i++, j++)
		{
			arr[i] = bucket[j];
		}

		delete[] count;
	}
	delete[] bucket;
}


// 返回数组中最大数的位数
int maxbits(int arr[], int length)
{
	int max_num = INT_MIN;
	for (int i = 0; i < length; i++)
	{
		max_num = max(arr[i], max_num);
	}
	int res = 0;
	while (max_num != 0)
	{
		max_num /= 10;
		res++;
	}
	return res;

}

// 计算得到一个数某一位中的值
int getDigit(int x, int d)
{
	return ((x / (static_cast<int>(pow(10, d - 1)))) % 10);
}
```

***todo:完成下面表格***    
排序稳定性：值相同的元素，排序以后他们的相对位置是否不变   
|       算法       | 时间复杂度 | 空间复杂度 | 稳定性 |
| :--------------: | :--------: | :--------: | :----: |
|     选择排序     |            |            |        |
|     冒泡排序     |            |            |        |
|     插入排序     |            |            |        |
|     归并排序     |            |            |        |
| 快速排序（随机） |            |            |        |
|      堆排序      |            |            |        |


####  哈希表
哈希表操作都是常数级别



#### 有序表
有序表操作都是O(logN)级别    
单链表节点结构   
双链表节点结构    
反转单向链表和双向链表    
打印两个有序链表的公共部分   
判断一个单链表是不是回文单链表    
（方法1：使用栈）
（方法2：使用快慢指针）   

有环链表相交问题

#### 二叉树
递归方式的先，中，后序遍历 
```cpp 
// 递归前序遍历 头-左-右
	void PreOrderTraverse(Node* head)
	{
		if (head == nullptr) return;
		cout << head->data << " ";
		PreOrderTraverse(head->left);
		PreOrderTraverse(head->right);
	}

	// 递归中序遍历 左-头-右
	void InOrderTraverse(Node* head)
	{
		if (head == nullptr) return;
		InOrderTraverse(head->left);
		cout << head->data << " ";
		InOrderTraverse(head->right);
	}

	// 递归后续遍历 左-右-头
	void PostOrderTraverse(Node* head)
	{
		if (head == nullptr) return;
		PostOrderTraverse(head->left);
		PostOrderTraverse(head->right);
		cout << head->data << " ";
	}
```  
非递归方式的先、中、后序遍历（使用栈）
```cpp
// 非递归前序遍历 头-左-右
	// 进栈顺序 头-右-左 不适用辅助栈
	void PreOrderTraverse(Node* head)
	{
		stack<Node*> stk;
		if (head == nullptr)
		{
			return;
		}
		stk.push(head);
		while (!stk.empty())
		{
			head = stk.top();
			stk.pop();
			cout << head->data << " ";
			// 注意：这里是先右进栈，再左进栈
			if (head->right != nullptr)
			{
				stk.push(head->right);
			}
			if (head->left != nullptr)
			{
				stk.push(head->left);
			}
			
		}
		cout << endl;
	}

	
	// 非递归中序遍历 左-头-右
	void InOrderTraverse(Node* head)
	{
		stack<Node*> stk;
		if (head == nullptr) return;
		
		while (!stk.empty() || head != nullptr)
		{
			if (head != nullptr)
			{
				stk.push(head);
				head = head->left;
			}
			else 
			{
				head = stk.top();
				cout << head->data << " ";
				head = head->right;
				stk.pop();
			}
		}
		cout << endl;
	}

	// 非递归后续遍历 左-右-头
	// 使用两个栈，有一个是辅助栈
	void PostOrderTraverse(Node* head)
	{
		stack<Node*> stk;
		stack<Node*> aux_stk;
		if (head == nullptr)
		{
			return;
		}
		stk.push(head);
		while (!stk.empty())
		{
			// 放入辅助栈
			head = stk.top();
			aux_stk.push(head);
			stk.pop();

			// 注意：这里先左边进栈，再右边进栈
			if (head->left != nullptr)
			{
				stk.push(head->left);
			}
			if (head->right != nullptr)
			{
				stk.push(head->right);
			}

		}
		while (!aux_stk.empty())
		{
			cout << aux_stk.top()->data << " ";
			aux_stk.pop();
		}
		cout << endl;
	}
```  
先序遍历：
* 从栈中弹出，记作cur
* 操作cur
* 先右再左入栈
* 重复  
中序遍历：分为（头右左和头左右）

#### 搜索二叉树
左数都比它小，右数都比他大    
判断一个树是否为搜索二叉树：中序遍历一直为非降序    
递归方式判断一棵树是否为搜索二叉树
```cpp
// 使用递归中序遍历，判断一个树是否为搜索二叉树 
	// 如果是BST，中序遍历结果为升序
	bool checkBST(Node* head)
	{
		if (head == nullptr)
		{
			return true;
		}
		// 判断左树是否为BST
		bool leftTree = checkBST(head->left);  
		if (!leftTree)
		{
			// 如果左树不是BST，直接返回false
			return false;
		}

		// 如果左树是BST，判断当前节点值是否大于MAX_VALUE
		if (head->data > MAX_VALUE)
		{
			MAX_VALUE = head->data;
		}
		else
		{
			return false;
		}

		return checkBST(head->right);
	}
	void process(Node* head, vector<Node*>& Node_vec)
	{
		if (head == nullptr)
		{
			return;
		}
		process(head->left, Node_vec);
		Node_vec.push_back(head);
		process(head->right, Node_vec);
	}

	bool checkBST2(Node* head)
	{
		vector<Node*> Node_vec;
		process(head, Node_vec);
		// 判断Node_vec中的Node的data是否升序
		for (int i = 0; i < Node_vec.size(); i++)
		{
			if (Node_vec[i]->data > MAX_VALUE)
			{
				MAX_VALUE = Node_vec[i]->data;
			}
			else
			{
				return false;
			}
		}
		return true;
	}
```
非递归的方式判断一棵树是否为搜索二叉树
```cpp
// 使用非递归中序遍历，判断一个树是否为搜索二叉树 
	// 如果是BST，中序遍历结果为升序
	bool checkBST(Node* head)
	{
		if (head == nullptr)
		{
			return true;
		}
		int preValue = INT_MIN;
		stack<Node*> stk;
		while (!stk.empty() || head != nullptr)
		{
			if (head != nullptr)
			{
				stk.push(head->left);
				head = head->left;
			}
			else
			{
				head = stk.top();
				stk.pop();
				if (head->data > preValue)
				{
					preValue = head->data;
				}
				else
				{
					return false;
				}
				stk.push(head->right);
			}
		}
		return true;
	}
```
二叉树套路解法判断一棵树是否为搜索二叉树  
***树型DP***
```cpp
1.左树是搜索二叉树
2.右树是搜索二叉树
3.当前节点大于左树最大值
4.当前节点小于右数最小值
// 使用二叉树套路解法判断一棵树是否为搜索
struct ReturnType {
	bool isBST;
	int max_value;
	int min_value;
	ReturnType(bool isBst, int max_v, int min_v) : isBST(isBst), max_value(max_v), min_value(min_v) {}
};

ReturnType* process(Node* head)
{
	if (head == nullptr)
	{
		return nullptr;
	}
	ReturnType* leftData = isBinarySearchTree::process(head->left);
	ReturnType* rightData = isBinarySearchTree::process(head->right);

	int min_v = head->data;
	int max_v = head->data;
	if (leftData != nullptr)
	{
		min_v = min(min_v, leftData->min_value);
		max_v = max(max_v, leftData->max_value);
	}
	if (rightData != nullptr)
	{
		min_v = min(min_v, rightData->min_value);
		max_v = max(max_v, rightData->max_value);
	}

	bool isBst = true;
	if (leftData != nullptr && (!leftData->isBST && leftData->max_value >= head->data))
	{
		isBst = false;
	}

	if (rightData != nullptr && (!rightData->isBST && rightData->min_value < head->data))
	{
		isBst = false;
	}

	ReturnType* result = new ReturnType(isBst, max_v, min_v);
	return result;
}

bool isBSTbyDP(Node* head)
{
	return isBinarySearchTree::process(head)->isBST;
}
```

#### 完全二叉树
只有最后一层有序不满   
使用宽度优先遍历
1) 有右还真没有左孩子，直接返回false
2) 在1满足的条件下，如果遇到的第一个左右不全，其后面节点全为叶子节点
```cpp
bool isCBT(Node* head)
{
	if (head == nullptr) return true;
	queue<Node*> que;
	Node* left = nullptr;
	Node* right = nullptr;
	// 是否遇到过左右两个孩子不全的情况(开关)
	bool leaf = false;
	que.push(head);
	while (!que.empty())
	{
		head = que.front();
		que.pop();
		left = head->left;
		right = head->right;

		// 1) 有右没有左孩子，直接返回false
		// 2) 在1满足的条件下，如果遇到的第一个左右不全，其后面节点全为叶子节点
		if (left == nullptr && right != nullptr || (leaf && (left != nullptr || right != nullptr)))
		{
			return false;
		}
		
		if (left != nullptr)
		{
			que.push(left);
		}
		if (right != nullptr)
		{
			que.push(right);
		}
		if (left == nullptr || right == nullptr)
		{
			leaf = true;
		}
	}
	return true;

```
#### 满二叉树

#### 平衡二叉树
每个子树，左树和右树的高度差不超过1    
1) 对于某个节点，左树是平衡二叉树
2) 对于某个节点，右树是平衡二叉树
3) 左树和右树的高度差小于等于1   
同时满足上面三个条件才是平衡二叉树
```cpp
struct returnType
{
	bool isBalanced;
	int height;
	returnType(bool isB, int h) : isBalanced(isB), height(h) { }
};

returnType* process(Node* head)
{
	returnType* result = new returnType(true, 0);
	// 空树也算平衡二叉树
	if (head == nullptr)
	{
		return result;
	}
	// 左树的信息
	returnType* leftType = process(head->left);
	// 右数的信息
	returnType* rightType = process(head->right);
	// 这棵树的信息
	result->height = max(leftType->height, rightType->height) + 1;
	result->isBalanced  = leftType->isBalanced && rightType->isBalanced && (abs(leftType->height - rightType->height) < 2);
	return result;
}

bool isBalance(Node* head)
{
	return process(head)->isBalanced;
}
```
#### 满二叉树
数的高度和节点个数：$Nodes_{num}=2^{height}-1$
```cpp
// 数据结构体
struct DataType
{
	double height;
	double num_nodes;
	
	DataType(double h, double num) : height(h), num_nodes(num) {}
};

DataType* isFBTProcess(Node* head)
{
	DataType* result = new DataType(0, 0);
	if (head == nullptr)
	{
		return result;
	}

	DataType* leftData = isFBTProcess(head->left);
	DataType* rightData = isFBTProcess(head->right);
	result->height = max(leftData->height, rightData->height) + 1;
	result->num_nodes = leftData->num_nodes + rightData->num_nodes + 1;
	return result;
}

bool isFBT(Node* head)
{
	DataType* result = isFBTProcess(head);
	if (result->num_nodes == pow(2, result->height) - 1)
	{
		return true;
	}
	else {
		return false;
	}
}
```
#### 最低公共祖先
 ```cpp
 Node* lowestAncestor(Node* head, Node* o1, Node* o2)
{
	// base case
	if (head == nullptr || head == o1 || head == o2)
	{
		return head;
	}

	Node* leftNode = lowestAncestor(head->left, o1, o2);
	Node* rightNode = lowestAncestor(head->right, o1, o2);

	if (leftNode != nullptr && rightNode != nullptr)
	{
		return head;
	}

	return leftNode != nullptr ? leftNode : rightNode;
}

// o1, o2一定属于head为头的树
// 返回o1和o2的最低公共祖先
Node* lowestAncestorRecord2(Node* head, Node* o1, Node* o2)
{
	unordered_map<Node*, Node*> fatherMap;
	// 自己的父节点是自己
	fatherMap[head] = head;
	LCAProcess(head, fatherMap);
	unordered_set<Node*> set1;
	Node* cur = o1;
	while (cur != fatherMap[cur])
	{
		set1.insert(cur);
		cur = fatherMap[cur];
	}
	set1.insert(head);

	// unordered_set<Node*> set2;
	cur = o2;
	while (cur != fatherMap[cur])
	{
		// set2.insert(cur);
		cur = fatherMap[cur];
		if (set1.find(cur) != set1.end())
		{的
			return cur;
		}
	}
	
	return head;
}

void LCAProcess(Node* head, unordered_map<Node*, Node*> fatherMap)
{
	if (head == nullptr)
	{
		return;
	}
	// 左孩子的父节点
	fatherMap[head->left] = head;
	// 右孩子的父节点
	fatherMap[head->right] = head;
	LCAProcess(head->left, fatherMap);
	LCAProcess(head->right, fatherMap);
}
 ```
#### 后继节点（中序遍历的下一个）

#### 二叉树的序列化和反序列化 

### 图
表示方法：邻接表和邻接矩阵
分类：有向图和无向图
```cpp
// 前向声明 Node 结构体
struct Node;

// 图的边结构
// 这是一个有向边，对于无向边的情况，(a->b)+(b->a)表示无向边
struct Edge {
	// 边的权重（距离）
	int weight;
	// 出发点
	Node* from;
	// 结束点
	Node* to;

	Edge(int w, Node* f, Node* t): weight(w), from(f), to(t) {}

};

// 图的节点的结构
struct Node
{
	// 节点上的值
	int value;
	// 节点入度
	int in;
	// 节点出度
	int out;
	// 当前节点出发相邻的点
	vector<Node*> nexts;
	// 当前节点出去的边（属于这个节点的边）
	vector<Edge*> edges;
	// 构造函数
	Node(int val)
	{
		this->value = val;
		this->in = 0;
		this->out = 0;
	}
};

// 图结构
struct Graph
{
	// 点集,int表示点的编号，Node*表示实际的点结构（数据项）
	unordered_map<int, Node*> nodes;
	// 边集，所有变组成的
	unordered_set<Edge*> edges;
};

// 构建一个图，输入为一个 N*3 的矩阵
// [from, to, weight]
Graph* createGraph(vector<vector<int>> matrix)
{
	Graph* graph = new Graph();
	for (int i = 0; i < matrix.size(); i++)
	{
		int from = matrix[i][0];
		int to = matrix[i][1];
		int weight = matrix[i][2];

		// 判断from节点是否已经保存在了点集中
		if (graph->nodes.find(from) == graph->nodes.end())
		{
			// 如果from节点不在点集中，保存到点集中
			Node* fromNode = new Node(from);
			graph->nodes.insert({ from, fromNode});
		}

		// 同理判断to节点
		if (graph->nodes.find(to) == graph->nodes.end())
		{
			Node* toNode = graph->nodes.at(to);
			graph->nodes.insert({ to, toNode });
		}

		// 如果存在graph中
		Node* fromNode = graph->nodes.at(from);
		Node* toNode = graph->nodes.at(to);
		// 新的边
		Edge* newEdge = new Edge(weight, fromNode, toNode);

		// 相邻点加入数组
		fromNode->nexts.push_back(toNode);
		// 出发节点出度++
		fromNode->out++;
		// 目的节点入度++
		toNode->in++;
		// 出发节点边加入数组
		fromNode->edges.push_back(newEdge);
		// 边加入graph的边集
		graph->edges.insert(newEdge);
	}
	return graph;
}
```
#### 图的宽度优先遍历
利用队列实现，从源节点开始依次按照宽度顺序进入队列，然后弹出，   
每弹出一个节点，把该节点没有进过队列的邻接点放入队列，直到队列变空
```cpp
// 图的宽度优先遍历
void graphBFS(Node* node)
{
	if (node == nullptr)
		return;

	queue<Node*> que;
	unordered_set<Node*> nodes_set;
	// 加入队列
	que.push(node);
	// 加入集合
	nodes_set.insert(node);
	while (!que.empty())
	{
		Node* cur = que.front();
		que.pop();
		// 宽度优先遍历的操作
		cout << cur->value << " ";
		// 将当前节点的nexts加入集合
		for (auto elem : cur->nexts)
		{
			// 如果不在nodes_set集合中
			if (nodes_set.find(elem) == nodes_set.end())
			{
				// 加入集合和队列中
				nodes_set.insert(elem);
				que.push(elem);
			}
		}
	}
}
```
#### 图的深度优先遍历
利用栈实现，从源节点开始放入栈中，弹出，   
每弹出一个节点，把该节点下一个没有进过栈的邻接点放入栈中，直到栈为空
```cpp
// 图的深度优先遍历
void graphDFS(Node* node)
{
	if (node == nullptr) return;
	// 使用栈
	stack<Node*> stk;
	unordered_set<Node*> nodes_set;
	stk.push(node);
	nodes_set.insert(node);
	while (!stk.empty())
	{
		Node* cur = stk.top();
		stk.pop();
		for (auto elem : cur->nexts)
		{
			// 判断是否在集合中
			if (nodes_set.find(cur) == nodes_set.end())
			{
				// 不在集合中，先把cur压入栈中，再把elem压入栈中,再把elem加到set中
				stk.push(cur);
				stk.push(elem);
				nodes_set.insert(elem);
				// 深度优先遍历的操作
				cout << elem->value << " ";
				// 每次自压入一个elem
				break;
			}
		}
	}
}
```
#### 拓扑排序算法
入度为0					
```cpp
// 拓扑排序
vector<Node*> sortedTopology(Graph* graph)
{
	// key: 某一个node
	// value: 剩余的入度
	unordered_map<Node*, int> inMap;
	// 入度为0的点，才能进入这个队列
	queue<Node*> zeroQueue;
	for (auto elem : graph->nodes)
	{
		// 将图中的每个节点及其每个节点的入度放入inMap
		inMap.insert({ elem.second, elem.second->in });
		if (elem.second->in == 0)
		{
			// 入度为0的node放入队列中
			zeroQueue.push(elem.second);
		}
	}
	// 拓扑排序的结果，以依次放入result中
	vector<Node*> result;
	while (!zeroQueue.empty())
	{
		Node* cur = zeroQueue.front();
		zeroQueue.pop(); 
		result.push_back(cur);
		// 将cur的nexts的所有入度减1
		for (auto next : cur->nexts)
		{
			auto it = inMap.find(next);
			it->second--;
			// 如果某个next的入度减为0,放入zeroQueue中
			if (inMap.at(next) == 0)
			{
				zeroQueue.push(next);
			}
		}
	}
	return result;
}
```
#### 最小生成树 
K算法   
克鲁斯卡尔算法   
普利姆算法   
Dijkstra算法

### 前缀树
namespace prefix_tre
{
	/**
	* @struct TrieNode
	* @brief 前缀树的一个节点
	*/
	struct TrieNode
	{
		int pass;  // 有多少经过了
		int end;  // 有多少在这里结尾
		vector<TrieNode*> nexts; // 表达路的方式
		// unordered_map<char, TrieNode*> nexts;  // 可以替换为HashMap

		TrieNode()
		{
			pass = 0;
			end = 0;
			nexts.resize(26, nullptr);
		}
	};

	/**
	* @class Trie
	* @brief 前缀树的一些算法
	*/
	class Trie
	{
	private:
		TrieNode* root; // 类Trie的成员变量

	public:
		/**
		* @brief 类的构造函数
		*/
		Trie()
		{
			root = new TrieNode();
		}

		/**
		* @brief 前缀树插入一个单词
		* @param word 一个string类型的字符串
		*/
		void insert(string word)
		{
			if (word.empty())
			{
				return;
			}
			
			const char* chs = word.c_str();  // 将一个字符串转为字符数组
			TrieNode* node = root;
			int index = 0;
			for (int i = 0; i < strlen(chs); i++)
			{
				index = chs[i] - 'a';
				if (node->nexts.at(index) == nullptr)
				{
					node->nexts.at(index) = new TrieNode();
				}
				node = node->nexts.at(index);
				node->pass++;
			}
			node->end++;

		}


		/**
		* @brief 检测一个word加入过几次,也就是出现了多少次
		* @param word:要检测的word
		* @return 加入的次数
		*/
		int search(string word)
		{
			if (word.empty())
			{
				return 0;
			}

			const char* chs = word.c_str();
			TrieNode* node = root;
			int index = 0;
			for (int i = 0; i < strlen(chs); i++)
			{
				index = chs[i] - 'a';
				if (node->nexts.at(index) == nullptr)
				{
					return 0;
				}
				node = node->nexts.at(index);
			}
			return node->end;
		}


		/**
		* @brief 所有加入的字符串中，有多少个以pre为前缀
		* @param pre:前缀
		* @return 以pre为前缀的个数
		*/
		int prefixNumder(string pre)
		{
			if (pre.empty()) {
				return 0;
			}

			const char* chs = pre.c_str();
			TrieNode* node = root;
			int index = 0;
			for (int i = 0; i < strlen(chs); i++)
			{
				index = chs[i] - 'a';
				if (node->nexts.at(index) == nullptr)
				{
					return 0;
				}
				node = node->nexts.at(index);
			}
			return node->pass;
		}

		
		/**
		* @brief 前缀树删除一个字符串
		* @param word:要删除的字符串
		*/
		void del(string word)
		{
			//先判断是否加入过
			if (search(word) != 0)
			{
				const char* chs = word.c_str();
				TrieNode* node = root;
				node->pass--; // 减少根节点的pass
				int index = 0;
				vector<TrieNode*> nodesToDelete; // 用来记录需要删除的节点
				for (int i = 0; i < strlen(chs); i++)
				{
					index = chs[i] - 'a';
					TrieNode* nextNode = node->nexts.at(index);
					nextNode->pass--; // 当前字符对应的节点的 pass 减 1
					if (nextNode->pass == 0) // 如果没有其他字符串经过该节点，准备删除
					{
						nodesToDelete.push_back(nextNode);
					}
					node = nextNode;
				}

				// 删除结束标记
				node->end--;

				// 从最后一个字符开始，逐层删除不再需要的节点
				for (int i = nodesToDelete.size(); i >= 0; --i)
				{
					TrieNode* nodeToDelete = nodesToDelete[i];
					// 如果没有其他字符串经过这个节点，删除这个节点
					if (nodeToDelete->pass == 0 && nodeToDelete->end == 0)
					{
						delete nodeToDelete;
					}
				}
			}
		}
	};
}

### 贪心算法

贪心算法在笔试时的解题套路
1. 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
2. 脑补出贪心策略A、贪心策略B、贪心策略C...
3. 用解法X和对数器，去验证每一个贪心策略，用实验的方法得知哪个贪心策略正确
4. 不纠结贪心策略的证明
```cpp
/ 会议安排(贪心算法)
namespace BestArrange
{
	/**
	* @struct Program
	* @brief 一个事件节点，成员函数为事件的开始事件和结束时间
	*/
	struct Program
	{
		int start;
		int end;
		Program(int s, int e)
		{
			this->start = s;
			this->end = e;
		}
	};

	/**
	* @brief 一个Programs的比较器，比较谁的结束时间早
	* @param p1:第一个事件
	* @param p2:第二个事件
	*/
	bool comparePrograms(const Program* p1, const Program* p2)
	{
		return p1->end < p2->end;
	}

	/**
	* @brief 事件安排的贪心算法，先安排结束时间早的时间
	* @param vector<Program*> programs:全部事件
	* @param int start:整体的开始时间
	* @return int result:能安排的事件数量
	*/
	int bestArrange(vector<Program*> programs, int start)
	{
		// 按照结束时间的前后排序
		sort(programs.begin(), programs.end(), comparePrograms);
		int result = 0;
		for (int i = 0; i < programs.size(); i++)
		{
			// 如果开始时间早与当前事件时间
			if (start <= programs[i]->start)
			{
				result++;
				// 更新开始时间
				start = programs[i]->end;
			}
		}
		return result;
	}
}
```

```cpp
namespace IPO
{
	struct Node
	{
		int p;
		int c;
		Node(int p, int c)
		{
			this->p = p;
			this->c = c;
		}
	};

	struct minCompare
	{
		bool operator()(Node* o1, Node* o2) const
		{
			return o1->c - o2->c;
		}
	};
	

	struct maxCompare
	{
		bool operator()(Node* o1, Node* o2) const
		{
			return o1->p - o2->p;
		}
	};

	

	int findMaximizedCapital(int k, int w, vector<int> profits, vector<int> capital)
	{
		vector<Node*> nodes;
		for (int i = 0; i < profits.size(); i++)
		{
			Node* node = new Node(profits[i], capital[i]);
			nodes.push_back(node);
		}

		priority_queue<Node*, vector<Node*>, minCompare> minCostQ;
		priority_queue<Node*, vector<Node*>, maxCompare> maxProfitQ;
		for (int i = 0; i < nodes.size(); i++)
		{
			minCostQ.push(nodes[i]);
		}
		for (int i = 0; i < k; i++)
		{
			while (!minCostQ.empty() && minCostQ.top()->c <= w)
			{
				maxProfitQ.push(minCostQ.top());
				minCostQ.pop();
			}
			if (maxProfitQ.empty())
			{
				return w;
			}
			w += maxProfitQ.top()->p;
			maxProfitQ.pop();
		}
		return w;
	}
}
```

一个数据流中，随时可以获得中位数
```cpp
/**
* @brief 快速获取数据流中的中位数
* 
*/
namespace MadianQuick
{
	/**
	* @class MedianHolder
	* @brief 快速获取数据流中的中位数
	*/
	class MedianHolder
	{
	private:
		// 大根堆
		priority_queue<int> maxHeap;
		// 小根堆
		priority_queue<int, vector<int>, greater<int>> minHeap;


		/**
		* @brief 调整两个堆的大小，确保两个堆的size相差不超过1
		*/
		void modifyTwoHeapsSize()
		{
			if (this->maxHeap.size() == this->minHeap.size() + 2)
			{
				// 如果大根堆的size比小根堆的size多2，将大根堆的头部元素放入小根堆
				minHeap.push(maxHeap.top());
				maxHeap.pop();
				
			}
			if (this->maxHeap.size() + 2 == this->minHeap.size())
			{
				// 如果小根堆的size比大根堆的size多2，将小根堆的头部元素放入大根堆
				maxHeap.push(minHeap.top());
				minHeap.pop();
			}
		}



	public:
		/**
		* @brief 将新的数据加入堆中,先根据num值确定放入打根堆还是小根堆，再调整堆的大小
		* @param num:要加入的值
		*/
		void addNumber(int num)
		{
			if (maxHeap.empty() || num <= maxHeap.top())
			{
				maxHeap.push(num);
			}
			else
			{
				minHeap.push(num);
			}

			modifyTwoHeapsSize();
		}


		/**
		* @brief 获取中值
		* @return 返回中值
		*/
		int getMedian()
		{
			int maxHeapSize = maxHeap.size();
			int minHeapSize = minHeap.size();
			if (maxHeapSize + minHeapSize == 0)
			{
				return NULL;
			}
			int maxHeapHead = maxHeap.top();
			int minHeapHead = minHeap.top();
			// 相加后的结果和1做与运算，判断奇偶
			if (((maxHeapSize + minHeapSize) & 1) == 0)
			{
				// 总数量为偶数，返回中间两个数的平均数
				return (maxHeapHead + minHeapHead) / 2;
			}
			return maxHeapHead > minHeapHead ? maxHeapHead : minHeapHead;
		}

	};

}
```
N皇后问题
```cpp
/**
* N皇后问题
*/
namespace NQueens
{
	/**
	* @class NQueens
	* @brief N皇后问题
	*/
	class NQueens
	{
	public:
		/**
		* @brief N皇后问题，用一个record数组记录每行皇后所在的列
		* @param n:一共有多少行
		* @return 有多少种放法
		*/
		int num1(int n)
		{
			if (n < 1)
			{
				return 0;
			}
			// record[i] -> 第i行的皇后，放在了第几列
			vector<int> record(n);
			return process1(0, record, n);

		}


		/**
		* @brief 
		* @param i:当前来到了第i行
		* @param record[0...i-1]:i之前的行，放了皇后的位置(record[0...i-1]的皇后，都不共行，不共列，不公斜线)
		* @param n:总共的行数
		* @return 摆完所有皇后，合理的摆法有多少种
		*/
		int process1(int i, vector<int>& record, int n)
		{
			if (i == n) // 中止行
			{
				return 1;
			}
			int res = 0;
			for (int j = 0; j < n; j++)  // 当前第i行，尝试所有列
			{
				// 当前i行的皇后，放在j列，会不会和之前的（0...i-1）的皇后，不共线共列或者共斜线
				// 如果是，认为无效
				// 如果不是，认为有效
				if (isValid(record, i, j))
				{
					record[i] = j;
					res += process1(i + 1, record, n);
				}
			}
			return res;
		}


		/*
		* @brief 判断第i行的皇后，放在第j列是否合法
		* @param vector<int>& record:记录（0...i-1）每个皇后缩放的行位置
		* @param int i:当前位于第i行
		* @param int j:当前行的皇后，放在第j列
		* @return bool:true表示合法，false表示不合法
		*/
		bool isValid(vector<int>& record, int i, int j)
		{
			for (int k = 0; k < i; k++)  // 之前的某一行皇后
			{
				// 判断是否共列和共斜线
				if (j == record[k] || abs(record[k] - j) == abs(i - k))
				{
					return false;
				}
			}
			return true;
		}


		/*
		* @brief N皇后问题常数优化版本
		* @param n:一共多少行，不要超过32
		* @return 多少中摆法
		*/
		int num2(int n)
		{
			if (n < 1 || n > 32)
			{
				return 0;
			}
			// 如果n等于32，limit被设置为-1
			// 如果n不等于32，limit被设置为一个二进制数，这个数在最低的n位上都是1，其余位都是0。
			// 例如，如果n是3，那么(1 << 3) - 1就是1000 - 1 = 0111（十进制为7）
			int limit = n == 32 ? -1 : (1 << n) - 1;
			return process2(limit, 0, 0, 0);
		}
		

		/*
		* @brief N皇后常数优化版本
		* @param limit
		* @param colLim:列的限制，1的位置不能放皇后，0的位置可以放
		* @param leftDiaLim:左斜线的限制，1的位置不能放皇后，0的位置可以
		* @param rightDiaLim:右斜线的限制，1的位置不能放皇后，0的位置可以
		* @return 合理的摆法
		*/
		int process2(int limit, int colLim, int leftDiaLim, int rightDiaLim)
		{
			if (colLim == limit)  // base case
			{
				return 1;
			}
			int pos = 0;
			int mostRightOne = 0;

			//所有候选皇后的位置，都在pos上
			pos = limit & (~(colLim | leftDiaLim | rightDiaLim));

			int res = 0;
			while (pos != 0)
			{
				// 提取候选皇后中，最右侧的1
				mostRightOne = pos & (~pos + 1);
				pos = pos - mostRightOne;
				res += process2(limit,
					colLim | mostRightOne,
					(leftDiaLim | mostRightOne) << 1,
					(rightDiaLim | mostRightOne) >> 1);
			}

			return res;
		}
	};
}
```
### 暴力递归
1. 把问题规模缩小为同类问题的子问题
2. 有明确的不需要继续进行递归的条件（base case）
3. 有当得到子问题的结果之后的决策过程
4. 不记录每个子问题的解


#### 汉诺塔问题：
```cpp
namespace Hanoi
{
	void func(int i, string start, string end, string other)
	{
		if (i == 1)
		{
			cout << "Move 1 from " + start + " to " + end << endl;
		}
		else
		{
			// 拆分
			func(i - 1, start, other, end);
			cout << "Move " << i << " from " << start << " to " << end << endl;
			func(i - 1, other, end, start);
		}
	}

	void hanoi(int i)
	{
		if (i > 1)
		{
			func(i, "左", "右", "中");
		}
	}
}
```
#### 打印一个字符串的所有子序列
```cpp
namespace PrintStr
{

	/*
	* @brief 打印字符串
	* @param res:保存char类型的数组
	*/
	void printList(const vector<char>& res)
	{
		if (res.empty())
		{
			cout << "_" << endl;
		}

		string str(res.begin(), res.end());
		cout << str << endl;
		
	}


	/*
	* @bried 拷贝字符数组
	* @param 原始字符数组
	* @return 拷贝后的字符数组
	*/
	vector<char> copyList(const vector<char>& res)
	{
		vector<char> copied;
		for (int i = 0; i < res.size(); i++)
		{
			copied.push_back(res[i]);
		}
		return copied;
	}

	/*
	* @brief 来到i位置，要和不要i位置的字符，有两条路
	* @param res:之前选择的组合，形成的列表
	*/
	void process(vector<char>& chs, int i, vector<char>& res)
	{
		if (i == chs.size())
		{
			printList(res);
			return;
		}

		vector<char> resKeep = copyList(res);
		resKeep.push_back(chs[i]);
		process(chs, i + 1, resKeep);
		vector<char> resNoInclude = copyList(res);
		process(chs, i + 1, resNoInclude);
	}


	/*
	* @brief 打印字符串的所有字串
	* @param s:原始字符串
	*/
	void prtstr(string s)
	{
		const char* chs = s.c_str();
		vector<char> chs_v;
		for (int i = 0; i < strlen(chs); i++)
		{
			chs_v.push_back(chs[i]);
		}
		vector<char> res;
		
		process(chs_v, 0, res);
	}


	/*
	* @brief 打印字符串的所有字串，节省内存版本，具体处理迭代过程
	* @param chs 保存字符串所有字串的数组
	* @param i 当前处理的第i个字符
	*/
	void process(vector<char>& chs, int i)
	{
		if (i == chs.size())
		{
			cout << string(chs.begin(), chs.end()) << endl;
			return;
		}

		process(chs, i + 1);
		char temp = chs[i];
		chs[i] = '0';
		process(chs, i + 1);
		chs[i] = temp;

	}

	
	/*
	* @brief 打印字符串的所有字串，节省内存版本
	*/
	void prtstr2(string s)
	{
		const char* chs = s.c_str();
		vector<char> chs_v;
		for (int i = 0; i < strlen(chs); i++)
		{
			chs_v.push_back(chs[i]);
		}
		process(chs_v, 0);
	}
}
```
#### 打印一个字符的全部排列
```cpp
namespace PrintAllPermutations
{
	void swap_chr(vector<char>& chs, int i, int j)
	{
		char temp = chs[i];
		chs[i] = chs[j];
		chs[j] = temp;
	}

	void process(vector<char>& chs, int i, vector<string>& res)
	{
		if (i == chs.size())
		{
			res.push_back(string(chs.begin(), chs.end()));
			// return;
		}

		bool visit[26] = { false };
		for (int j = i; j < chs.size(); j++)
		{
			if (!visit[(chs[j] - 'a')])
			{
				visit[chs[j] - 'a'] = true;
				swap_chr(chs, i, j);
				process(chs, i + 1, res);
				swap_chr(chs, i, j);
			}
		}
	}

	void prtAllStr(vector<string> res)
	{
		for (int i = 0; i < res.size(); i++)
		{
			cout << res[i] << endl;
		}
	}

	void Permutations(string str)
	{
		vector<string> res;
		if (str.size() == 0)
		{
			return;
		}
		const char* chs = str.c_str();
		vector<char> vec_chs;
		for (int i = 0; i < strlen(chs); i++)
		{
			vec_chs.push_back(chs[i]);
		}
		process(vec_chs, 0, res);

		prtAllStr(res);
		
	}
}
```

#### 题目
```cpp
namespace CardsInline
{
	int s(vector<int>& arr, int i, int j);
	int f(vector<int>& arr, int i, int j)
	{
		if (i == j)
		{
			return arr[i];
		}
		return max(arr[i] + s(arr, i + 1, j), arr[j] + s(arr, i, j - 1));
	}

	int s(vector<int>& arr, int i, int j)
	{
		if (i == j)
		{
			return 0;
		}
		return min(f(arr, i + 1, j), f(arr, i, j - 1));
	}


	int win1(vector<int>& arr)
	{
		if (arr.empty())
		{
			return 0;
		}

		return max(f(arr, 0, arr.size() - 1), s(arr, 0, arr.size() - 1));
	}
}
```
#### 逆序一个栈，不能申请额外的数据结构，只能使用递归函数
```cpp
namespace InverseStack
{
	/*
	* @brief 返回并移除一个栈的栈底元素
	*/
	int getAndRemoveLastElement(stack<int>& stk)
	{
		int result = stk.top();
		stk.pop();
		if (stk.empty())
		{
			return result;
		}
		else
		{
			int last = getAndRemoveLastElement(stk);
			stk.push(result);
			return last;
		}
	}      
	* @brief 逆序一个栈
	*/
	void reverse(stack<int>& stk)
	{
		if (stk.empty())
		{
			return;
		}
		int i = getAndRemoveLastElement(stk);
		reverse(stk);
		stk.push(i);
	}

}
```
#### 题目
```cpp
namespace ConvertToLetterString
{
	int process(vector<char>& chs, int i)
	{
		if (i == chs.size())
		{
			return 1;
		}
		if (chs[i] == '0')
		{
			return 0;
		}
		if (chs[i] == '1')
		{
			int res = process(chs, i + 1);
			if (i + 1 < chs.size())
			{
				res += process(chs, i + 2);
			}
			return res;
		}

		if (chs[i] == '2')
		{
			int res = process(chs, i + 1);
			if(i + 1 < chs.size() && (chs[i + 1] >= '0' && chs['i+1'] <= '6'))
			{
				res += process(chs, i + 2);
			}
			return res;
		}

		return process(chs, i + 1);
	}


	int number(string s)
	{
		vector<char> vec_chr;
		const char* chs = s.c_str();
		for (int i = 0; i < strlen(chs); i++)
		{
			vec_chr.push_back(chs[i]);
		}

		return process(vec_chr, 0);
	}
}
```

#### 背包问题
```cpp

```


# 基础提升

## 哈希函数和哈希表
哈希函数：
1. 输入是无穷的，输出是有范围的。MD5:0~ 2^64-1 SHA:0~2^128-1
2. same in -> same out(不随机)
3. dif in -> same out(哈希碰撞)
4. 均匀离散 

### 题目：设计RandomPool结构
设计一种结构，在结构中有如下三种功能：
1. insert(key):将某个key加入到该结构中，做到不重复加入
2. delete(key):将原本在结构中的某个key移除
3. getRandom():等概率随机返回结构中的任何一个key
要求：insert、delete和getRandom方法的时间复杂度都是O(1)   
```cpp
namespace RandomPool
{
	// 定义一个模板类 Pool
	template <typename T>
	class Pool
	{
	private:
		// keyIndexMap 用于存储键到索引的映射
		unordered_map<T, int> keyIndexMap;
		// indexKeyMap 用于存储索引到键的映射
		unordered_map<int, T> indexKeyMap;
		// size 用于记录池中元素的数量
		int size;
		
	public:
		// 构造函数，初始化 size 为 0
		Pool()
		{
			this->size = 0;
		}

		// 插入一个键
		void insert(T key)
		{
			// 如果键不在 keyIndexMap 中
			if (this->keyIndexMap.find(key) == this->keyIndexMap.end())
			{
				// 将键和当前大小作为索引存入 keyIndexMap
				this->keyIndexMap[key] = this->size;
				// 将当前大小作为索引和键存入 indexKeyMap
				this->indexKeyMap[this->size++] = key;
			}
		}

		// 删除一个键
		void deleteKey(T key)
		{
			// 如果键在 keyIndexMap 中
			if (this->keyIndexMap.find(key) != this->keyIndexMap.end())
			{
				// 获取要删除的索引
				int deleteIndex = this->keyIndexMap.at(key);
				// 获取最后一个元素的索引
				int lastIndex = --this->size;
				// 获取最后一个元素的键
				T lastKey = this->indexKeyMap.at(lastIndex);
				// 更新最后一个元素的索引为要删除的索引
				this->keyIndexMap[lastKey] = deleteIndex;
				// 更新要删除的索引为最后一个元素的键
				this->indexKeyMap[deleteIndex] = lastKey;
				// 从 keyIndexMap 中删除该键
				this->keyIndexMap.erase(key);
				// 从 indexKeyMap 中删除最后一个元素的索引
				this->indexKeyMap.erase(lastIndex);
			}
		}

		// 获取一个随机键
		T getRandom()
		{
			// 如果池为空，返回类型 T 的默认值
			if (this->size == 0)
			{
				return T();
			}

			// 设置随机数种子
			srand(static_cast<unsigned int>(time(0)));
			// 生成一个随机索引
			int randomIndex = rand() % this->size;
			
			// 返回随机索引对应的键
			return this->indexKeyMap.at(randomIndex);
		}
	};

	// 测试 Pool 类
	void testPool()
	{
		RandomPool::Pool<int> pool;
		
		// 测试插入和获取随机键
		pool.insert(1);
		assert(pool.getRandom() == 1);

		// 测试删除键
		pool.deleteKey(1);
		assert(pool.getRandom() == 0);  // int 类型的默认值是 0

		// 测试插入多个键
		pool.insert(2);
		pool.insert(3);
		pool.insert(4);
		int randomValue = pool.getRandom();
		assert(randomValue == 2 || randomValue == 3 || randomValue == 4);

		// 测试删除多个键
		pool.deleteKey(2);
		pool.deleteKey(3);
		assert(pool.getRandom() == 4);

		// 测试插入重复键
		pool.insert(4);
		assert(pool.getRandom() == 4);

		// 测试在空池中获取随机键
		pool.deleteKey(4);
		assert(pool.getRandom() == 0);  // int 类型的默认值是 0
	}

	// 主函数
	int main()
	{
		testPool();

		return 0;
	}
}
```

### 布隆过滤器
只有加入和查询，没有删除，允许一定程度上的失误  
https://blog.csdn.net/qq_41125219/article/details/119982158
```cpp
/*
* @namespace ByteArr
* @brief 用一个int类型数组实现一个byte数组, 并实现设置某一位的值为1, 以及测试设置某一位的值为1的功能
*/
namespace ByteArr
{
	// 声明一个长度为 10 的整型数组, 用于存储 320 位的数据
	int arr[10] = {0};  // 32bit * 10 = 320bit

	// arr[0] int 0~31
	// arr[1] int 32~63
	// arr[2] int 64~95
	// ...

	/*
	* @brief 设置第 i 位的值为 1
	* @param i 第 i 位
	*/
	void setBit(int i)
	{
		int numIndex = i / 32;  // numIndex = 5
		int bitIndex = i % 32;  // bitIndex = 18

		// 设置第 i 位的值为 1
		arr[numIndex] = arr[numIndex] | (1 << bitIndex);
	}

	void testSetBit()
	{
		int i = 178;  // 想要设置第 178 位的值为 1

		setBit(i);

		// 验证第 178 位的值是否为 1
		int numIndex = i / 32;
		int bitIndex = i % 32;
		int value = (arr[numIndex] >> bitIndex) & 1;
		assert(value == 1);
	}
}
```
### 哈希一致性(虚拟节点)
https://developer.aliyun.com/article/1082388    
https://blog.csdn.net/ThinPikachu/article/details/123300298


### 岛问题
```cpp
// 岛问题, 统计岛的数量, 1 代表陆地, 0 代表海洋, 相邻的陆地属于同一个岛, 横向和纵向相邻, 不包括斜向。
namespace island
{	
	void infect(vector<vector<int>>& arr, int i, int j, int row, int col);
	

	/*
	* @brief 统计岛的数量
	* @param arr 二维数组
	* @return 岛的数量
	*/
	int countIsland(vector<vector<int>>& arr)
	{
		int row = static_cast<int>(arr.size());
		int col = static_cast<int>(arr[0].size());

		int res = 0;
		for(int i = 0; i < row; i++)
		{
			for (int j = 0; j < col; j++)
			{
				if (arr[i][j] == 1)
				{
					res++;
					infect(arr, i, j, row, col);
				}
			}
		}

		return res;
	}


	/*
	* @brief 感染函数
	* @param arr 二维数组
	* @param i 行索引
	* @param j 列索引
	* @param row 行数
	* @param col 列数
	* @return void
	*/
	void infect(vector<vector<int>>& arr, int i, int j, int row, int col)
	{
		if (i < 0 || i >= row || j < 0 || j >= col || arr[i][j] != 1)
		{
			return;
		}
		arr[i][j] = 2;
		infect(arr, i, j - 1, row, col);
		infect(arr, i, j + 1, row, col);
		infect(arr, i - 1, j, row, col);
		infect(arr, i + 1, j, row, col);

	}

	void testCountIsland()
	{
		std::vector<std::vector<int>> arr = {
			{1, 1, 0, 0, 0},
			{1, 1, 0, 0, 0},
			{0, 0, 1, 0, 0},
			{0, 0, 0, 1, 1}
		};

		int islandCount = countIsland(arr);
		assert(islandCount == 3);
	}
}
```


## 并查集
```cpp
// 并查集
namespace UnionFind
{
	/*
	* @brief 并查集元素
	* @class Element
	* @tparam V 元素类型
	*/
	template <typename V>
	struct Element
	{
		V value;
		Element(V value) : value(value) {}
	};


	/*
	* @class UnionFindSet
	* @brief 并查集
	* @tparam V 元素类型
	*/
	template <typename V>
	class UnionFindSet
	{
	public:
		unordered_map<V, Element<V>*> elementMap; // 元素到元素信息的映射
		unordered_map<Element<V>*, Element<V>*> fatherMap; // 元素到父元素的映射
		unordered_map<Element<V>*, int> sizeMap; // 集合大小

		UnionFindSet(vector<V> arr)
		{
			for (V value : arr)
			{
				Element<V>* element(value);  // 创建元素
				elementMap[value] = element;  // 将元素存入 elementMap
				fatherMap[element] = element;  // 将元素的父元素设为自己
				sizeMap[element] = 1;  // 将元素的集合大小设为 1
			}
		}


		/*
		* @brief 判断两个元素是否属于同一个集合
		* @param a 元素 a
		* @param b 元素 b
		* @return 是否属于同一个集合
		*/
		bool isSameSet(V a, V b)
		{
			if (elementMap.find(a) != elementMap.end() && elementMap.find(b) != elementMap.end())
			{
				return (findHead(elementMap.at(a)) == findHead(elementMap.at(a)));
			}
			return false;
		}



		/*
		* @brief 合并两个集合
		* @param a 元素 a
		* @param b 元素 b
		* @return void
		*/
		void unionSet(V a, V b)
		{
			if (elementMap.find(a) != elementMap.end() && elementMap.find(b) != elementMap.end())
			{
				Element<V>* aF = findHead(elementMap.at(a));
				Element<V>* bF = findHead(elementMap.at(a));
				if (aF != bF)
				{
					Element<V>* big = sizeMap.at(aF) >= sizeMap.at(bF) ? aF : bF;
					Element<V>* small = big == aF ? bF : aF;
					fatherMap.at(small) = big;
					sizeMap.at(big) = sizeMap.at(aF) + sizeMap.at(bF);
					sizeMap.erase(small);
				}
 			}
		}

	private:
		/*
		* @brief 查找元素的头节点, 并进行路径压缩
		* @param element 元素
		* @return 元素的头节点
		*/
		Element<V>* findHead(Element<V>* element)
		{
			stack<Element<V>*> paths;
			while (element != fatherMap.at(element))
			{
				paths.push(element);
				element = fatherMap.at(element);
			}

			while (!paths.empty())
			{
				fatherMap.at(paths.top()) = element;
				paths.pop();
			}

			return element;
		}

	};
}
```
## KMP（字符串匹配算法）
字符串str1和str2，str1是否包含str2，如果包含返回str2在str1中开始的位置，如何做到时间复杂度O(N)完成    
前缀和后缀
```cpp
// KMP算法
namespace KMP
{
	/*
	* @brief 获取 next 数组。next 数组的含义是字符串 s 的前缀和后缀的最长公共元素的长度。
	最长公共元素的长度是指字符串的前缀和后缀的最长公共元素的长度。
	* @param strVec 字符串向量
	* @return next 数组
	*/
	vector<int> getNextArray(vector<char> strVec)
	{
		if (strVec.size() == 1)  // 如果字符串长度为 1
		{
			return vector<int>{-1};
		}

		vector<int> nextArray(strVec.size(), 0);  // 初始化 next 数组
		nextArray[0] = -1;  // next 数组的第一个元素为 -1
		nextArray[1] = 0;  // next 数组的第二个元素为 0
		int i = 2;  // i 从 2 开始
		int cn = 0;  // cn 从 0 开始。cn 表示当前字符的前一个字符的前缀和后缀的最长公共元素的长度
		while(i < strVec.size())  // 遍历字符串
		{
			if (strVec[i - 1] == strVec[cn])  // 如果当前字符的前一个字符和 cn 位置的字符相等
			{
				nextArray[i++] = ++cn;  // next 数组的值为 cn + 1
			}
			else if (cn > 0)  // 如果当前字符的前一个字符和 cn 位置的字符不相等, 且 cn 大于 0
			{
				cn = nextArray[cn];  // cn 回退到 next 数组的值
			}
			else {  // 如果当前字符的前一个字符和 cn 位置的字符不相等, 且 cn 等于 0
				nextArray[i++] = 0;  // next 数组的值为 0
			}
		}
		return nextArray;
	}

	/*
	* @brief 获取字符串 s1 中字符串 s2 的索引
	* @param s1 字符串 s1
	* @param s2 字符串 s2
	* @return 字符串 s2 的索引
	*/
	int getIndexOf(string s1, string s2)
	{
		// 如果 s1 为空, s2 为空, s1 的长度小于 s2 的长度, 返回 -1
		if (s1.empty() || s2.empty() || s1.size() < s2.size())
		{
			return -1;
		}
		
		// 将字符串转换为字符数组
		const char* str1 = s1.c_str();
		const char* str2 = s2.c_str();

		int i1 = 0;  // s1 的索引
		int i2 = 0;  // s2 的索引

		vector<char> str1Vec(str1, str1 + s1.size());  // 字符串 s1 的字符数组
		vector<char> str2Vec(str2, str2 + s2.size());  // 字符串 s2 的字符数组

		
		vector<int> nextArray = getNextArray(str2Vec);  // 获取 next 数组


		while (i1 < s1.size() && i2 < s2.size())
		{
			if (str1Vec[i1] == str2Vec[i2])  // 如果两个字符相等
			{
				i1++;
				i2++;
			}
			else if (nextArray[i2] == -1)  // 如果 i2 已经到达 s2 的开头
			{
				i1++;  // i1 向后移动
			}
			else {  // 如果两个字符不相等
				i2 = nextArray[i2];  // i2 回退到 next 数组的值
			}
		}
		return i2 == s2.size() ? i1 - i2 : -1;
	}
}
```

## Manacher算法
解决字符串中最长回文子串,（回文半径数组）
```cpp
namespace Manacher
{
	/*
	* @brief 获取 Manacher 字符串
	* @param str 字符串
	* @return Manacher 字符串
	*/
	vector<char> manacherString(string str)
	{
		const char* chs = str.c_str();
		vector<char> res(str.size() * 2 + 1);  // 修复：使用 str.size() 而不是 strlen(chs)
		int index = 0;
		for (int i = 0; i < res.size(); i++)
		{
			res[i] = ((i & 1) == 0) ? '#' : chs[index++];
		}

		return res;
	}

	/*
	* @brief 获取最长回文子串
	* @param str 字符串
	* @return 最长回文子串
	*/
	int maxLcpsLength(string s)
	{
		if(s.empty())
		{
			return 0;
		}

		vector<char> strVec = manacherString(s);  // 获取 Manacher 字符串
		vector<int> pArr(strVec.size(), 0);  // 回文半径数组
		int R = -1;  // 回文右边界
		int C = -1;  // 回文中心
		int max_length = INT_MIN;  // 最长回文子串的长度
		
		for (int i = 0; i < strVec.size(); i++)
		{
			// 如果 i 在 R 的范围内, pArr[2 * C - i] 和 R - i 的最小值, 否则为 1。
			// pArr[2 * C - i]为 i 关于 C 的对称点的回文半径, R - i 为 i 到 R 的距离
			pArr[i] = R > i ? min(pArr[2 * C - i], R - i) : 1;

			// 以 i 为中心向两边扩展, 直到不能扩展为止
			// i - pArr[i] 为左边界, i + pArr[i] 为右边界
			while (i + pArr[i] < strVec.size() && i - pArr[i] > -1)
			{
				if (strVec[i + pArr[i]] == strVec[i - pArr[i]])  // 如果两个字符相等
				{
					pArr[i]++;  // 回文半径加 1
				}
				else {  // 如果两个字符不相等
					break;
				}
			}
			if (i + pArr[i] > R)  // 更新回文右边界和中心
			{
				R = i + pArr[i];
				C = i;
			}
			max_length = max(max_length, pArr[i]);
		}
		return max_length - 1;
	}
}
```
## 滑动窗口
```cpp
// 滑动窗口最大值
namespace SlidingWindowMaxArray
{
	/*
	* @brief 获取滑动窗口最大值
	* @param arr 数组
	* @param w 窗口大小
	* @return 滑动窗口最大值
	*/
	vector<int> getMaxWindow(vector<int> arr, int w)
	{
		//	如果数组为空, 窗口大小小于 1, 数组大小小于窗口大小, 返回空数组
		if (arr.empty() || w < 1 || arr.size() < w)
		{
			return vector<int>();
		}

		deque<int> qmax;  // 双端队列, 用于存储最大值的索引, 队列头部存储最大值的索引, 队列尾部存储次大值的索引
		vector<int> res(arr.size() - w + 1);  // 结果数组
		int index = 0;
		for (int i = 0; i < static_cast<int>(arr.size()); i++)
		{
			while (!qmax.empty() && arr[qmax.back()] <= arr[i])  // 如果队列不为空, 且队尾元素小于等于当前元素
			{
				qmax.pop_back();  // 弹出队尾元素
			}
			qmax.push_back(i);  // 将当前元素的索引存入队列

			// 如果队头元素不在窗口内, 弹出队头元素
			if (qmax.front() == i - w)  // 如果队头元素不在窗口内
			{
				qmax.pop_front();  // 弹出队头元素
			}
			
			// 如果 i 大于等于 w - 1, 将队头元素存入结果数组
			if (i >= w - 1)
			{
				res[index++] = arr[qmax.front()];
			}
			
		}

		return res;
	}
}
```

## 单调栈
```cpp
namespace MonotonousStack
{
	/*
	* @brief 获取正整数数组中每个元素左右两边离它最近的比它小的元素的索引,如果不存在则为 -1, 且数组中没有重复元素
	* @param arr 数组
	* @return 比它小的元素的索引
	*/
	vector<vector<int>> getNearLessNoRepeat(vector<int> arr)
	{
		vector<vector<int>> res(arr.size(), vector<int>(2));  // 结果数组
		stack<int> lessStack;  // 递增单调栈, 存储索引, 栈顶元素为当前元素左边离它最近的比它小的元素的索引

		for (int i = 0; i < static_cast<int>(arr.size()); i++)  
		{
			// 当栈不为空且栈顶元素大于当前元素时
			while (!lessStack.empty() && arr[lessStack.top()] > arr[i])  
			{
				int popIndex = lessStack.top();  // 弹出元素的索引
				lessStack.pop(); 
				int leftLessIndex = lessStack.empty() ? -1 : lessStack.top();  // 弹出元素左边离它最近的比它小的元素的索引
				res[popIndex][0] = leftLessIndex;
				res[popIndex][1] = i;
			}
			lessStack.push(i);
		}

		// 处理栈中剩余的元素
		while (!lessStack.empty())
		{
			int popIndex = lessStack.top();
			lessStack.pop();
			int leftLessIndex = lessStack.empty() ? -1 : lessStack.top();  // 弹出元素左边离它最近的比它小的元素的索引
			res[popIndex][0] = leftLessIndex;
			res[popIndex][1] = -1;
		}
		return res;
	}

	/*
	* @brief 获取正整数数组中每个元素左右两边离它最近的比它小的元素的索引,如果不存在则为 -1, 且数组中有重复元素
	* @param arr 数组
	* @return 比它小的元素的索引
	*/
	vector<vector<int>> getNearLess(vector<int> arr)
	{
		vector<vector<int>> res(arr.size(), vector<int>(2));  // 结果数组
		stack<vector<int>> lessStack;  // 递增单调栈, 存储索引, 栈顶元素为当前元素左边离它最近的比它小的元素的索引

		for (int i = 0; i < static_cast<int>(arr.size()); i++)
		{
			// 当栈不为空且栈顶元素大于当前元素时
			while (!lessStack.empty() && arr[lessStack.top()[0]] > arr[i])
			{
				vector<int> popIndex = lessStack.top();  // 弹出元素的索引
				lessStack.pop();
				int leftLessIndex = lessStack.empty() ? -1 : lessStack.top().back();  // 弹出元素左边离它最近的比它小的元素的索引

				for (int popi : popIndex)
				{
					res[popi][0] = leftLessIndex;
					res[popi][1] = i;
				}
			}
			// 如果栈顶元素等于当前元素，将当前索引加入栈顶元素的索引列表
			if (!lessStack.empty() && arr[lessStack.top()[0]] == arr[i])
			{
				lessStack.top().push_back(i);
			}
			else
			{
				vector<int> indexVec;
				indexVec.push_back(i);
				lessStack.push(indexVec);
			}
		}

		// 处理栈中剩余的元素
		while (!lessStack.empty())
		{
			vector<int> popIndex = lessStack.top();
			lessStack.pop();
			int leftLessIndex = lessStack.empty() ? -1 : lessStack.top().back();  // 弹出元素左边离它最近的比它小的元素的索引

			for (int popi : popIndex)
			{
				res[popi][0] = leftLessIndex;
				res[popi][1] = -1;
			}
		}
		return res;
	}
}
```

## 树型dp套路

### 二叉树节点之间的最大距离
从二叉树的a节点出发，可以向上或者向下走，但沿途的节点只能经过一次，到达b节点的路径上的节点个数叫做a到b的距离。求整棵树上最大距离。
```cpp
namespace MaxDistanceTree
{
	/*
	* @brief 获取二叉树中的最大距离
	*/
	struct Node
	{
		int data;
		Node* left;
		Node* right;

		Node(int data)
		{
			this->data = data;
			this->left = nullptr;
			this->right = nullptr;
		}
	};


	/*
	* @brief 获取二叉树中的最大距离
	*/
	struct ReturnType
	{
		int maxDistance;  // 最大距离
		int height;  // 高度

		ReturnType(int maxDistance, int height)
		{
			this->maxDistance = maxDistance;
			this->height = height;
		}
	};


	ReturnType process(Node* head)
	{
		// 如果头节点为空
		if (head == nullptr)
		{
			return ReturnType(0, 0);
		}

		ReturnType leftData = process(head->left);  // 处理左子树
		ReturnType rightData = process(head->right); // 处理右子树
		int includeHeadDistance = leftData.height + rightData.height + 1;  // 头节点包含的最大距离
		int p1 = leftData.maxDistance;  // 左子树的最大距离
		int p2 = rightData.maxDistance;  // 右子树的最大距离
		int resultDiatance = max(max(p1, p1), includeHeadDistance);  // 最大距离
		int resultHeight = max(leftData.height, rightData.height) + 1;  // 高度
		
		return ReturnType(resultDiatance, resultHeight);
	}
}
```

### 最大快了值
```cpp
/*
* @namespace MaxHappy
* @brief 员工的最大快乐值
*/
namespace MaxHappy
{
	/*
	* struect Employee
	* @brief 员工结构体
	*/
	struct Employee
	{
		int happy;  // 快乐值
		vector<Employee*> subordinates;  // 下属
	};


	/*
	* @brief 获取员工的最大快乐值
	*/
	struct ReturnType
	{
		int yesHappy;  // 包含当前员工的最大快乐值
		int noHappy;  // 不包含当前员工的最大快乐值

		ReturnType(int yesHappy, int noHappy)
		{
			this->yesHappy = yesHappy;
			this->noHappy = noHappy;
		}
	};

	ReturnType process(Employee* employee)
	{
		// 如果员工为空
		if(employee->subordinates.empty())
		{
			return ReturnType(employee->happy, 0);
		}

		int yesHappy = employee->happy;  // 包含当前员工的最大快乐值
		int noHappy = 0;  // 不包含当前员工的最大快乐值

		for (Employee* sub : employee->subordinates)
		{
			ReturnType subData = process(sub);  // 处理下属员工
			yesHappy += subData.noHappy;  // 当前员工来了，下属就不能来
			noHappy += max(subData.noHappy, subData.yesHappy);  // 当前员工不来，下属可以来也可以不来
		}

		return ReturnType(yesHappy, noHappy);
}
```

### Morris遍历

一种遍历二叉树的方式，时间复杂度为O(N)，空间复杂度为O(1)   
通过利用原树中大量的空闲指针的方式，达到节省空间的目的
```cpp
// Morris 遍历
namespace Morris
{
	struct Node
	{
		int data;
		Node* left;
		Node* right;

		Node(int data)
		{
			this->data = data;
			this->left = nullptr;
			this->right = nullptr;
		}
	};

	void morris(Node* head)
	{
		if (head == nullptr)
		{
			return;
		}

		Node* cur = head;
		Node* mostRight = nullptr;
		while (cur != nullptr)
		{
			mostRight = cur->left;
			if (mostRight != nullptr)  // 如果左子树不为空
			{
				// 找到左子树的最右节点
				while (mostRight->right != nullptr && mostRight->right != cur)
				{
					mostRight = mostRight->right;
				}
				if (mostRight->right == nullptr)  // 如果mostRight的右节点为空，第一次来到cur
				{
					mostRight->right = cur;
					cur = cur->left;
					continue;
				}
				else  // mostRight->right == cur,第二次来到cur
				{
					mostRight->right = nullptr;
				}
			}
			cur = cur->right;
		}
	}

	/*
	* @brief Morris 先序遍历,访问一次的节点直接打印，访问两次的节点第一次访问时打印
	*/
	void morrisPre(Node* head)
	{
		if (head == nullptr)
		{
			return;
		}

		Node* cur = head;
		Node* mostRight = nullptr;
		
		while (cur != nullptr)  
		{
			mostRight = cur->left;
			if (mostRight != nullptr)  // 如果左子树不为空
			{
				while (mostRight->right != nullptr && mostRight->right != cur)
				{
					mostRight = mostRight->right;
				}
				if (mostRight->right == nullptr)  // 如果mostRight的右节点为空，表示第一次来到cur
				{
					mostRight->right = cur;
					cout << cur->data << " ";  // 先序遍历
					cur = cur->left;
					continue;
				}
				else
				{
					mostRight->right = nullptr;
				}
			}
			else
			{
				cout << cur->data << " ";  // 先序遍历
			}

			cur = cur->right;
		}

		cout << endl;
		
	}


	/*
	* @brief Morris 中序遍历,访问一次的节点直接打印，访问两次的节点第二次访问时打印
	*/
	void morrisIn(Node* head)
	{
		if (head == nullptr)
		{
			return;
		}

		Node* cur = head;
		Node* mostRight = nullptr;
		while (cur != nullptr)
		{
			mostRight = cur->left;
			if (mostRight != nullptr)  // 如果左子树不为空
			{
				// 找到左子树的最右节点
				while (mostRight->right != nullptr && mostRight->right != cur)
				{
					mostRight = mostRight->right;
				}
				if (mostRight->right == nullptr)  // 如果mostRight的右节点为空，第一次来到cur
				{
					mostRight->right = cur;
					cur = cur->left;
					continue;
				}
				else  // mostRight->right == cur,第二次来到cur
				{
					mostRight->right = nullptr;
				}
			}
			cout << cur->data << " ";  // 中序遍历
			cur = cur->right;
		}
	}


	/*
	* @brief 逆序打印边界节点
	* @param from 边界节点
	*/
	Node* reverseEdge(Node* from)
	{
		Node* pre = nullptr;
		Node* next = nullptr;
		while (from != nullptr)
		{
			next = from->right;
			from->right = pre;
			pre = from;
			from = next;
		}
		return pre;
	}

	/*
	* @brief 打印边界节点
	*/
	void PrintEdge(Node* head)
	{
		Node* tail = reverseEdge(head);
		Node* cur = tail;
		while (cur != nullptr)
		{
			cout << cur->data << " ";
			cur = cur->right;
		}
		reverseEdge(tail);
	}

	/*
	* @brief Morris 后序遍历，具体过程如下：
	* 1. 如果当前节点有左孩子，找到左子树的最右节点，将当前节点设置为最右节点的右孩子
	* 2. 如果当前节点没有左孩子，当前节点向右移动
	* 3. 如果当前节点的右孩子为空，将当前节点设置为当前节点的右孩子
	* 4. 如果当前节点的右孩子不为空，将当前节点的右孩子设置为空，逆序打印当前节点的左孩子的右边界，然后将当前节点设置为当前节点的右孩子
	* 5. 重复步骤 3 和 4，直到当前节点为空
	* @param head 头节点
	*/
	void morrisPos(Node* head)
	{
		if (head == nullptr)
		{
			return;
		}

		Node* cur = head;
		Node* mostRight = nullptr;
		while (cur != nullptr)
		{
			mostRight = cur->left;
			if (mostRight != nullptr)  // 如果左子树不为空
			{
				// 找到左子树的最右节点
				while (mostRight->right != nullptr && mostRight->right != cur)
				{
					mostRight = mostRight->right;
				}
				if (mostRight->right == nullptr)  // 如果mostRight的右节点为空，第一次来到cur
				{
					mostRight->right = cur;
					cur = cur->left;
					continue;
				}
				else  // mostRight->right == cur,第二次来到cur
				{
					mostRight->right = nullptr;
					PrintEdge(cur->left);  // 逆序打印左边界
				}
			}
			cur = cur->right;
		}
		PrintEdge(head);  // 逆序打印右边界
		cout << endl;
	}
}
```
## 资源限制类题目


## 位运算题目
### 给定两个有符号32位整数a和b，返回a和b中较大的，不用做任何比较判断
```cpp
namespace GetMax
{
	/*
	* @brief 异或运算
	* @param n 数字 n
	*/
	int flip(int n)
	{
		return n ^ 1;
	}


	/*
	* @brief 获取数字的符号。正数返回 1，负数返回 0
	*/
	int sign(int n)
	{
		return flip((n >> 31) & 1);
	}


	/*
	* @brief 获取两个数的最大值, 不使用比较运算符,这种情况可能会导致溢出
	*/
	int getMax1(int a, int b)
	{
		int c = a - b;
		int scA = sign(c);  // a - b 的符号
		int scB = flip(scA);  // a 和 b 的符号
		return a * scA + b * scB;  // a * scA + b * scB = a * 1 + b * 0 = a
	}

	
	/*
	* @brief 获取两个数的最大值，不使用比较运算符，不会导致溢出 
	*/
	int getMax2(int a, int b)
	{
		int c = a - b;
		int sc = sign(c);  // a - b 的符号
		int sa = sign(a);  // a 的符号
		int sb = sign(b);  // b 的符号
		int difSab = sa ^ sb;  // a 和 b 的符号是否相同, 相同为 0，不同为 1
		int sameSab = flip(difSab);  // a 和 b 的符号是否相同, 相同为 1，不同为 0
		int returnA = sameSab * sc + difSab * sa;  // 如果 a 和 b 的符号相同，返回 a - b 的符号，否则返回 a 的符号
		int returnB = flip(returnA);  // 如果 a 和 b 的符号相同，返回 b - a 的符号，否则返回 b 的符号
		return a * returnA + b * returnB;  // a * returnA + b * returnB = a * 1 + b * 0 = a
	}
}
```

### 判断是否是2和4的幂
```cpp
namespace Power
{
	/*
	* @brief 判断一个数是否是 2 的幂, 具体过程如下：
	* 1. 如果一个数是 2 的幂，那么它的二进制表示中只有一个 1，其余都是 0
	* 2. n & (n - 1) 的结果是将 n 的二进制表示中最右边的 1 变为 0
	* 3. 如果 n 是 2 的幂，那么 n & (n - 1) 的结果是 0
	* @param n 数字 n
	* @return 是否是 2 的幂
	*/
	bool is2Power(int n)
	{
		return (n & (n - 1)) == 0;
	}


	/*
	* @brief 判断一个数是否是 4 的幂，具体过程如下：
	* 1. 如果一个数是 4 的幂，那么它的二进制表示中只有一个 1，其余都是 0
	* 2. 0x55555555 的二进制表示为 0101 0101 0101 0101 0101 0101 0101 0101
	* 3. 如果 n 是 4 的幂，那么 n & 0x55555555 的结果不为 0
	* @param n 数字 n
	* @return 是否是 4 的幂
	*/
	bool is4Power(int n)
	{
		return ((n & (n - 1)) == 0) && ((n & 0x55555555) != 0);
	}
}
```
### 位运算实现加减乘除
```cpp
namespace AddMinusMutiDivideByBite
{
	/*
	* @brief 通过位运算实现加法，加法结果不能溢出的前提下, 具体过程如下：
	* 1. 两个数相加，不考虑进位，相加的结果为 a ^ b
	* 2. 两个数相加，只考虑进位，相加的结果为 a & b
	* 3. 将 a ^ b 和 a & b 的结果左移一位，然后相加，直到 a & b 的结果为 0
	* @param a 数字 a
	* @param b 数字 b
	*/
	int add(int a, int b)
	{
		int sum = a;
		while (b != 0)
		{
			sum = a ^ b;  // 无进位相加
			b = (a & b) << 1; // 进位
			a = sum;  // 无进位相加结果
		}
		return sum;
	}


	/*
	* @brief 取一个数的相反数，通过取反加 1 来实现
	* @param n 数字 n
	*/
	int negate(int n)
	{
		return add(~n, 1);
	}


	/*
	* @brief 通过位运算实现减法,加上相反数即可
	*/
	int miuns(int a, int b)
	{
		return add(a, negate(b));
	}


	/*
	* @brief 通过位运算实现乘法，具体过程如下：
	*/
	int mutil(int a, int b)
	{
		int res = 0;
		while (b != 0)
		{
			if ((b & 1) != 0)
			{
				res = add(res, a);
			}
			a <<= 1;
			b >>= 1;
		}
		return res;
	}


	/*
	* @brief 判断是否是负数
	*/
	bool isNeg(int n)
	{
		return n < 0;
	}


	/*
	* @brief 通过位运算实现除法，具体过程如下：
	* 1. 如果 a 和 b 都是正数，直接计算
	* 2. 如果 a 和 b 都是负数，计算 a 和 b 的绝对值的商
	* 3. 如果 a 和 b 一个是正数，一个是负数，计算 a 和 b 的绝对值的商，然后取反
	*/
	int div(int a, int b)
	{
		int x = isNeg(a) ? negate(a) : a;  // a 的绝对值
		int y = isNeg(b) ? negate(b) : b;  // b 的绝对值

		int res = 0;
		for (int i = 31; i > -1; i = miuns(i, 1))  // 从 31 位开始
		{
			if ((x >> i) >= y)  // 如果 x 的第 i 位大于等于 y
			{
				res |= (1 << i);  // 结果加上 1 << i
				x = miuns(x, y << i);  // x 减去 y << i
			}
		}
		return isNeg(a) ^ isNeg(b) ? negate(res) : res;   // 如果 a 和 b 一个是正数，一个是负数，取反
	}
}
```

### 机器人到达指定位置
```cpp
namespace RobotWalk
{
	/*
	* @brief 机器人走路问题
	* @param N 位置总数
	* @param M 机器人初始位置
	* @param K 剩余步数
	* @param P 最终位置
	* @return 走到最终位置的方法数
	*/
	int way1(int N, int M, int K, int P)
	{
		// 参数无效直接返回0
		if (N < 2 || M < 1 || K < 1 || M > N || P > N || P < 1)
		{
			return 0;
		}

		// 总共N个位置，从M点出发，还剩K步，返回最终能达到P的方法数
		return walk1(N, M, K, P);
	}


	/*
	* @brief 机器人走路问题
	* @param N 位置总数
	* @param cur 当前位置
	* @param rest 剩余步数
	* @param P 最终位置
	*/
	int walk1(int N, int cur, int rest, int P)
	{
		// 如果剩余步数为 0，当前位置为最终位置，如果当前位置等于最终位置，返回 1，否则返回 0
		if (rest == 0)
		{
			return cur == P ? 1 : 0;
		}

		// 如果当前位置为 1，只能往右走
		if (cur == 1)
		{
			return walk1(N, 2, rest - 1, P);
		}

		// 如果当前位置为 N，只能往左走
		if (cur == N)
		{
			return walk1(N, N - 1, rest - 1, P);
		}

		//如果位于中间位置，可以往左走也可以往右走
		return walk1(N, cur - 1, rest - 1, P) + walk1(N, cur + 1, rest - 1, P);
	}


	int ways(int N, int M, int K, int P)
	{
		if (N < 2 || M < 1 || P < 1 || K < 1 || M > N || P > N)
		{
			return 0;
		}

		vector<vector<int>> dp(K + 1, vector<int>(N + 1));  // 动态规划数组，dp[i][j] 表示第 i 步在 j 位置上的方法数
		dp[0][P] = 1;  // 第 0 步在 P 位置上的方法数为 1
		for (int i = 1; i <= K; i++)
		{
			for (int j = 1; j <= N; j++)
			{
				if (j == 1)
				{
					dp[i][j] = dp[i - 1][2];  // 第 i 步在 1 位置上的方法数为 i - 1 步在 2 位置上的方法数
				}
				else if (j == N)
				{
					dp[i][j] = dp[i - 1][N - 1];  // 第 i 步在 N 位置上的方法数为 i - 1 步在 N - 1 位置上的方法数
				}
				else
				{
					dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][i + 1];  // 第 i 步在 j 位置上的方法数为 i - 1 步在 j - 1 位置上的方法数和 i - 1 步在 j + 1 位置上的方法数
				}
			}
		}
		return dp[K][M];  // 返回 K 步在 M 位置上的方法数

	}

	int way3(int N, int M, int K, int P)
	{
		if (N < 2 || M < 1 || P < 1 || K < 1 || M > N || P > N)
		{
			return 0;
		}

		vector<int> dp(N + 1);  // 动态规划数组，dp[j] 表示第 i 步在 j 位置上的方法数
		dp[P] = 1;  // 第 0 步在 P 位置上的方法数为 1
		for (int i = 1; i <= K; i++)
		{
			int leftUp = dp[1];  // 左上角的值
			for (int j = 1; j <= N; j++)
			{
				int tem = dp[j];  // 临时变量, 保存 dp[j] 的值, 用于计算 dp[j + 1]
				if (j == 1)
				{
					dp[j] = dp[j + 1];  // 第 i 步在 1 位置上的方法数为 i - 1 步在 2 位置上的方法数
				}
				else if (j == N)
				{
					dp[j] = leftUp;  // 第 i 步在 N 位置上的方法数为 i - 1 步在 N - 1 位置上的方法数
				}
				else
				{
					dp[j] = leftUp + dp[j + 1];  // 第 i 步在 j 位置上的方法数为 i - 1 步在 j - 1 位置上的方法数和 i - 1 步在 j + 1 位置上的方法数
				}
				leftUp = tem;  // 更新左上角的值
			}
		}
		return dp[M];  // 返回 K 步在 M 位置上的方法数
	}
}
```
### 还钱的最少货币数
```cpp
namespace CoinsMin
{
	int minCoins1(vector<int> arr, int aim)
	{
		if (arr.empty() || aim < 0)
		{
			return -1;
		}

		return process1(arr, 0, aim);
	}

	int process1(vector<int> arr, int index, int aim)
	{
		// base case：
		// 已经没有面值能够考虑了
		// 如果此时剩余的钱为0，返回0张
		// 如果此时剩余的钱不是0，返回-1
		if (index == arr.size())
		{
			return aim == 0 ? 0 : -1;
		}

		int res = -1;  // 最少张数,	初始化为 -1, 表示无解

		// 依次尝试使用当前面值(arr[i])0张、1张、k张，但不能超过rest
		for (int k = 0; k * arr[index] <= aim; k++)
		{
			// 使用了k张arr[i]，剩下的钱为rest - k * arr[i]
			// 交给剩下的面值去搞定(arr[i+1..N-1])
			int next = process1(arr, index + 1, aim - k * arr[index]);
			if (next != -1)
			{
				res = res == -1 ? next + k : min(res, next + k);
			}
		}

		return res;
	}


	int minCoins(vector<int> arr, int aim)
	{
		if (arr.empty() || aim < 0)
		{
			return -1;
		}

		int N = arr.size();
		vector<vector<int>> dp(N + 1, vector<int>(aim + 1));  // 动态规划数组，dp[i][j] 表示使用 arr[i..N-1] 面值，组成 j 需要的最少张数

		for (int col = 1; col <= aim; col++)
		{
			dp[N][col] = -1;  // 最后一行的值为 -1
		}

		for (int i = N - 1; i >= 0; i--)  //从底往上计算每一行
		{
			for (int rest = 0; rest <= aim; rest++)  // 每一行都是从左往右计算
			{
				dp[i][rest] = - 1;  // 初始化为 -1
				if (dp[i + 1][rest] != -1) // 如果下面的值有效
				{
					dp[i][rest] = dp[i + 1][rest];  // 下面的值赋给当前值
				}
				// 左边的值不越界，且有效
				if (rest - arr[i] >= 0 && dp[i][rest - arr[i]] != -1)
				{
					if (dp[i][rest] == -1)
					{
						dp[i][rest] = dp[i][rest - arr[i]] + 1;
					}
					else
					{
						dp[i][rest] = min(dp[i][rest], dp[i][rest - arr[i]] + 1);
					}
				}
			}
		}
		return dp[0][aim];
	}
}
```
   